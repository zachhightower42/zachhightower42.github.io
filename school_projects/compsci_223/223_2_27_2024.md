#test2
**Floating point**
`float tmp = -12.75;
`
So how do we store this?
Step 1: $-1100.11_2$ 
Step 2: Convert to formula, we have to move the binary point so that we have a leading decimal point E.g. 1.11 etc. 
$-1.10011 \times 2^3$
$(-1)^{1,Sign of bit}(1.0011)\times2^{130-127}$
Step 3: Concatenate

| s   | exp                            | frac                              |
| --- | ------------------------------ | --------------------------------- |
| 1   | (Where 130's bit pattern goes) | (where 1.0011's bit pattern goes) |

Equation for single precision 
$(-1)^{s}\times(1.)\times2^{exp-127}$
Equation for double precision
$(-1)^{s}\times(1.)\times2^{exp-1023}$

Example
$$-12.75=-1100.11_2=-1.10011\times2^3=(-1)^{1}\times(1.10011)\times2^{10000000010}$$


| s   | exp         | frac         |
| --- | ----------- | ------------ |
| 1   | 10000000010 | 10011000...0 |
| 0x  | C02         | 9 8 0000000  |
|     |             |              |
**Benefits of the IEE 754 standard**
- Easy to compare floating points

**Conversion, normalized mode**
In this standard we have two different kinds of 0, -0 and +0. Artifact of the standard requiring signs

Very very small numbers near 0 are considered de-normalized. E.g. *0.000000000001*

Positive infinity and negative infinity sit at our right and left edges of the coverage line

Outside of the line are irrational or NaN numbers, like $\sqrt2$ 

- Exp is neither all 0s nor all 1s
- Exponent E coded as a biased value: $E=exp-Bias$
	- Bias
		- Single precision: 127 (exp: 1...254, E: -126...127)
		- Double precision: 1023(exp: 1...2046, E: -1022...1023)

**Example, Conversion of binary to Floating point**
0x4144000

Step 1: convert hex to binary 

0x4144000

| s   | exp      | frac       |
| --- | -------- | ---------- |
| 0   | 10000010 | 100010...0 |
$$(-1)^{0}\times(1.00001)\times2^{10000010-127}$$

$=1.00001\times2^{3}$
$=1100.01_{2}$
$=12.25^2$

**Limitations**
- Not all rational numbers can be encoded. 
	- Can exactly represent only rational numbers of the form $x\timess^k$
	- Can not represent numbers with repeating bit patterns
		- 1/3 `0.010101010101...`
		- 1/5
		- 1/10
**Different modes (Values)**
1. Normalized Mode
exp is neither 000...0 or 111...1
2. Denormalized mode
exp is 000...0
This is used to represent 0 and very small numbers close to 0 
3. Special mode
exp is 111...1
Used to represent infinity and NaN (not a Number/irrational numbers)
If frac is 000...- then it represents infinity 
If frac is NOT 000...0 then it represents NaN
NaN represents case when no numeric value can be determined 
E.g $$\sqrt-1, \infty, -\infty,...etc.$$


**Special mode (Value)**

| s   | exp       | frac     |     |
| --- | --------- | -------- | --- |
| 1   | 11111...1 | 0000...0 |     |
$-\infty$


**Special properties**
- Floating point zero is the same as integer zero 
	- All bits are zero in both cases 
- Comparison can be done just like an unsigned integer 
	- First, compare sign bits (must consider -0 = 0 )
	- Next, compare bits from the left to right.
	1. De-normalized, normalized, infinity values do not matter
	- NaNs are problematic
	1. Will be bigger than any other values
**Rounding**

IEEE 754 supports 4 different rounding modes


|                        | 1.4 | 1.6 | 1.5 | 2.5 | -1.5 |
| ---------------------- | --- | --- | --- | --- | ---- |
| Towards zero           | 1   | 1   | 1   | 2   | -1   |
| Rounds down            | 1   | 1   | 1   | 2   | -2   |
| Round up               | 2   | 2   | 2   | 3   | -1   |
| Nearest even (default) | 1   | 2   | 2   | 2   | -2   |

	Why different rounding modes?
Different applications

## ISA and x86

	Relationship between assembly code and machine code?
Essentially the same thing, assembly = next step up towards human readable. Basically machine code made human readable is assembly 

High level to assembly code is completely different though.

**ISA instruction set architecture**
Interface between software and hardware
	SW/compiler assumes and HW promises
Abstraction of the format and behavior of the processor
Examples: x86, ARM, MIPS, PowerPC, Alpha, and many more

It's a portion of the computer visible to ASM programmer or compiler writer

Standard for hardware design

Why different ISAs? Different target workloads
	Desktop: good performance of various programs
	Database, file and web servers: floating-point is not as important
	Mobile and embedded: energy consumption, code size, and memory footprint become the most important considerations

**What does ISA include**

Machine instructions
	Opcodes, Addressing,modes, data types, instructins types and Formats
	Registers, Condition codes
**Macro vs Micro Archictecture**

ISA is considered as macro architecture

Microarchitecture
	Implementation of macro architecture
	Not visible to software
	Analogy:
	gas pedal (Macro) : interface for acceleration 
	Engine (micro): implementation of acceleration
Micro architecture can vary as long as it satisfies macro architecture *ISA*
	x86 ISA has many implementations, micro architectures - Inteal: Ivy bridge, Sky lake, etc... AMD: Bulldozer, ryzen, etc...


**x86 ISA**
Dominates laptop/desktop/server market
	major manufacturers: Intel, AMD, and more

Evolutionary design
	Backwards compatible up until 8086 introduced in 1978
	Added more features as time goes on